# Формат данных
    source_id { 
  
      features:
        [x_1, x_2, ..., x_n],  - координата точки измерения (широта)
        [y_1, y_2, ..., y_n],  - координата точки измерения (долгота)
        [rssi_1, rssi_2, ..., rssi_n] - сила сигнала в точке измерения
    
      targets:
        source_x,  - координата источника (широта)
        source_y,  - координата источника (долгота)
        [azimuth_1, azimuth_2, ..., azimuth_n] - направление к источнику из каждой точки измерения (угол от севера)
        [distance_1, distance_2, ..., distance_n] - расстояние от точки измерения до источника сигнала
    }

source_id представляет собой 1 тренеровочную запись. То есть имея на входе N измерений, мы для них должны получить N азимутов и расстояний и/или 1 координату источника. 
Нужно отметить, что по идее в обучающем наборе достаточно иметь лишь координаты источника, а азимуты и расстояния можно вычислить в рамках feature engineering

Модель должна научиться учитывать:
- Пространственную составляющую: как точки измерений расположены друг относительно друга, на каком расстоянии и с какой стороны
- Физическую (?) составляющую: меньшая rssi должна вносить меньший вклад в предсказание


# Предобработка данных

### Координаты

Все координаты первым делом должны пройти минмакс масштабирование в промежуток от 0 до 1, причем мин и макс координаты нужно задать заранее, чтобы определить рабочу область:

$$
x_{\text{norm}} = \frac{x - x_{\min}}{x_{\max} - x_{\min}}, \quad
y_{\text{norm}} = \frac{y - y_{\min}}{y_{\max} - y_{\min}}
$$

Так как просто цифры ни о чем не говорят, не несут в себе никакой пространственной инфы для модели, то надо ее извлечь с помощью позиционного кодирования.

$$
\mathrm{PE}(x, i) = \sin\\bigl(x \cdot 10000^{-\tfrac{2i}{d}}\bigr), \quad
\mathrm{PE}(x, i+1) = \cos\\bigl(x \cdot 10000^{-\tfrac{2i}{d}}\bigr)
$$

где d — размерность эмбеддинга, i — индекс измерения.

Допустим если взять min = 0 и max = 10, и закодировать в этих пределах координату {5;7}, сначала она станет {0.5;0.7}, а потом 
          
    tensor[ 0.4794,  0.8776, -0.2624,  0.9650,  0.6442,  0.7648,  0.7739,  0.6333]

при размерности тензора = 8. Можно брать и больше, это по сути гиперпараметр.


### Сила сигнала (RSSI)

Данный параметр пока что единственное что характеризует расстояние до источника сигнала:

$$
P_d = P_0 - 10 \cdot n \cdot \lg\\bigl(\tfrac{d}{d_0}\bigr)
$$

Видно что по отношению к расстоянию данный параметр имеет логарифмическую зависимость. Можно было бы от нее избавиться во время нормализации, но я думаю что данную специфику лучше учесть при построении функции потерь либо физически информированного модуля сети. 
Так или иначе данный параметр необходимо нормализоватть в промежуток от 0 до 1. мин и макс параметры для RSSI будут -30 (отличный сигнал) и -120 (сигнал потерян). Эти границы могут разнитсья в зависимости от стандарта связи, но суть остается та же.

### Направление на источник

Так как азимут имеет циклическую природу (0° = 360°) необходимо использовать специальное кодирование, например через пару синус косинус:

$$
azimuth_{sin} = \sin\left( \frac{2 \pi \theta}{360} \right), \quad
azimuth_{cos} = \cos\left( \frac{2 \pi \theta}{360} \right)
$$

Это поможет устранить проблему цикличности и приведет значения в диапазон от -1 до 1.
Например Для 30° (северо-восток, 13 часов 30 минут): 

    sin(30°) = 0.5, cos(30°) ≈ 0.866.

### Расстояния до источника

Так как это обычный скаляр то значение просто нормализуется в промежуток от 0 до 1 в соответствии с граничными значениями рабочей области.

Однако данный признак можно использовать вместе с направлением (азимутом) посредством позиционного кодирования, чтобы сохранить пространыственную информацию. Посколько сила сигнала нелинейно зависит от расстояния, такое кодирование поможет модель выявить эту закономерность.
Например, для азимута 30° (северо-восток, 13 часов 30 минут) и расстояния 500 м и рабочей области от 0 до 1000:

    sin(30°) = 0.5, cos(30°) ≈ 0.866.

    500 м => 0.05

    tensor[0.5, 0.866, 0.0499, 0.9987, 0.0005, 0.9999]



Ссылка на пространственный енкодинг: https://machinelearningmastery.com/a-gentle-introduction-to-positional-encoding-in-transformer-models-part-1/


По итогу получается датасет следующей структуры:

    | Features:
    | ├─ RSSI: (BATCH_SIZE, MEASUREMENT_COUNT, 1)
    | └─ Coordinates: (BATCH_SIZE, MEASUREMENT_COUNT, d)
    |
    | Targets:
    | ├─ Source Coords: (BATCH_SIZE, 1, d)
    | ├─ Azimuths: (BATCH_SIZE, MEASUREMENT_COUNT, 2)
    | ├─ Distances: (BATCH_SIZE, MEASUREMENT_COUNT, 1)
    | └─ Combined Vectors: (BATCH_SIZE, MEASUREMENT_COUNT, 2 + d)

Где BACTH_SIZE - размер выборки (количество source_id), MEASUREMENT_COUNT - количество точек измерений, d - размерность эмбеддинга для пространственного кодирования


# Цели обучения

Конечной и главной целью модели является предсказание точной координаты источника сигнала. Однако эту цель можно разбить на несколько подцелей:
1) Предсказания направления к источнику сигнала из каждой точки измерения. Пространственная характеристика, которая в большей степени зависит от от геометрии задачи, и в меньшей от RSSI (хватит простого в А больше чем в В)  
2) Предсказание расстояния от каждой точки измерения до источника сигнала. Данный параметр непосредственно связан с RSSI, который логарифмически зависит от расстояния до источника. На деле также зависит от среды распространения, но это скорее физическая поправка.
3) Усреднение направления и расстояния от всех точек измерения и нахождение координаты или области расположения источника.

**Отсюда могу построить предположение: На этапе предобучения модель должна с нуля научиться с какой-то точностью предсказывать шаги 1 и 2. Затем веса модели будут уточняться, вноситься поправки на физику распространения сигнала, и модель будет дообучаться до шага 3.**
