# Формат данных
    source_id { 
  
      features:
        [x_1, x_2, ..., x_n],  - координата точки измерения (широта)
        [y_1, y_2, ..., y_n],  - координата точки измерения (долгота)
        [rssi_1, rssi_2, ..., rssi_n] - сила сигнала в точке измерения
    
      targets:
        source_x,  - координата источника (широта)
        source_y,  - координата источника (долгота)
        [azimuth_1, azimuth_2, ..., azimuth_n] - направление к источнику из каждой точки измерения (угол от севера)
    }

source_id представляет собой 1 тренеровочную запись. То есть имея на входе N измерений, мы для них должны получить N азимутов и/или 1 координату источника.

Модель должна научиться учитывать:
- Пространственную составляющую: как точки измерений расположены друг относительно друга, на каком расстоянии и с какой стороны
- Физическую (?) составляющую: меньшая rssi должна вносить меньший вклад в предсказание


# Предобработка данных

### Координаты

1) Все координаты первым делом должны пройти минмакс масштабирование в промежуток от 0 до 1, причем мин и мак координаты нужно задать заранее, чтобы определить рабочу область:

![image](https://github.com/user-attachments/assets/2d62db66-e2c9-4c0e-8942-b261c1601b61)

2) Так как просто цифры ни о чем не говорят, не несут в себе никакой пространственной инфы для модели, то надо ее извлечь с помощью позиционного кодирования.

![image](https://github.com/user-attachments/assets/98d360ee-5bd1-4867-bb00-b0f9e2d40a48)
где d — размерность эмбеддинга, i — индекс измерения.

Допустим если взять min = 0 и max = 10, и закодировать в этих пределах координату {5;7}, сначала она станет {0.5;0.7}, а потом 
          
    tensor([[ 0.4794,  0.8776, -0.2624,  0.9650,  0.6442,  0.7648,  0.7739,  0.6333]])

при размерности тензора = 8. Можно брать и больше, это по сути гиперпараметр.


### Нормализация rssi  
